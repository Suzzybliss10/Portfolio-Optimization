---
title: "Portfolio Optimization"
author: "Susan Dangana"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
tinytex::install_tinytex(force = TRUE)
```

## PART 1
 
## CONSTRUCTION OF A PORTFOLIO  
### PORTFOLIO 1: GA generated weight and manually selected assets

```{r Fetch Data, include=FALSE}
require(GA)
require(quantmod)

myStocks <- c("AMZN", "NKE", "CVX", "GOOGL", "MCD", "NFLX", "AAPL", "MSFT", "PG", "WMT")

# Create an empty list to save fetched stock data
stockDataList <- list()

# Iterate over each stock symbol in myStocks
for (stock in myStocks) {
  # Fetch the stock data for the current stock symbol
  stockData <- getSymbols(stock, src = "yahoo", from = "2021-01-01", to = "2023-12-31", auto.assign = FALSE)
  
  # Save the fetched stock data in the stockDataList
  stockDataList[[stock]] <- stockData
}

```

### Save and View Data
```{r view data, }

# Save the data in a .RData from where the data will be loaded from in subsequent runs
save(stockDataList, file = "stock_data.RData")


load("stock_data.RData")
#head(stockDataList)

```

### Get Monthly Return and Split into Train and test sets
```{r Monthly Returns, include=FALSE}

# Create empty list to save monthly returns of each stock
monthlyRet <- list()

for (stock in myStocks) {
  stockData <- stockDataList[[stock]]
  monthlyRet[[stock]] <- monthlyReturn(stockData)
}

# Create initial dataframe of monthly return by Merging the returns of the first two stocks in the myStocks list

myMonthlyRet <- merge(monthlyRet[[1]], monthlyRet[[2]])

# Merge the remaining stocks to this initial return dataframe
for  (i in 3:length(myStocks)) {
  myMonthlyRet <- merge(myMonthlyRet, monthlyRet[[i]])
}

# use the actual stock name as heading as opposed to index
colnames(myMonthlyRet) <- myStocks


#Split dataset into train and test sets (80% train, 20% test)

set.seed(123) 
selected_indices <- sample(1:nrow(myMonthlyRet), 0.8 * nrow(myMonthlyRet))
trainData <- myMonthlyRet[selected_indices, ]
testData <- myMonthlyRet[-selected_indices, ]

```

### Fitness Function Definition

```{r Fitness function}

# Objective function to maximize the Sharpe ratio

fitnessFunction <- function(weights, meanReturn, covMatrix) {
  # Calculate portfolio return based on the given weights
  portfolioReturn <- sum(weights * meanReturn)
  
  # Calculate the portfolio risk
  portfolioRisk <- sqrt(t(weights) %*% covMatrix %*% weights) 
  
  # Calculate the Sharpe ratio
  sharpe_ratio <- portfolioReturn / portfolioRisk
  
  # Maximize the sharpe ratio
  return(-sharpe_ratio)
}
```

### Portfolio Optimization using GA
```{r GA Optimization, include=FALSE}

# Set up the GA parameters
GA <- ga(type = "real-valued",
         fitness = fitnessFunction,
         lower = rep(0, length(myStocks)),
         upper = rep(1, length(myStocks)),
         meanReturn = colMeans(trainData),
         covMatrix = cov(trainData),
         popSize = 50,
         maxiter =100
)
```

```{r Optimal weights}
# Get optimal weight
optimalWeights <- GA@solution
print(optimalWeights)
```
##  EVALUATION OF PORTFOLIO 1 ON UNSEEN DATA (TEST SET)

```{r} 

# Define function to calculate portfolio metrics

portfolioMetrics <- function(weights, meanReturn, covMatrix) {
  # Calculate portfolio return based on the given weights
  portfolioReturn <- sum(weights * meanReturn)
  
  # Calculate the portfolio risk
  portfolioRisk <- sqrt(t(weights) %*% covMatrix %*% weights) 
  
  # Calculate the Sharpe ratio
  sharpe_ratio <- portfolioReturn / portfolioRisk
  # Maximize the sharpe ratio
 return(list(Return = portfolioReturn, Risk = portfolioRisk, Sharpe_Ratio = sharpe_ratio))
}

# Assign the mean return and risk for the train data to a variable
meanRet_train <- colMeans(trainData)
risk_train <- cov(trainData)
# Assign the mean return and risk for the test data to a variable
meanRet_test <- colMeans(testData)
risk_test <- cov(testData)

# Change the optimalWeight from a matrix to a vector
optimalWeights <- as.vector(optimalWeights)

# Calculate portfolio metrics for train and test sets

portfolio_1_Metrics_train <- portfolioMetrics(optimalWeights, meanRet_train, risk_train)
portfolio_1_Metrics_test <- portfolioMetrics(optimalWeights, meanRet_test, risk_test)  

print(portfolio_1_Metrics_train)
print(portfolio_1_Metrics_test)
```
#### Observation of Performance
When evaluating the portfolio performance on unseen "future" data, there's a noticeable decrease in both return and risk metrics compared to the performance on the train set.
he Sharpe ratio on the test set (0.0506) is also lower than the Sharpe ratio on the train set (0.0603), indicating that the risk-adjusted return decreased when the portfolio was applied to unseen data.

Overall, the optimized weights generated by the GA performed less effectively when applied to the test set, suggesting that the model might have overfit the training data or failed to capture the underlying patterns in the test data. Further refinement or validation of the model might be necessary to improve its performance on unseen data.

###  PORTFOLIO 2: Balanced Portfolio weights
```{r}
# Balanced portfolio where all weights are even
n_stocks <- length(myStocks)
balancedWeights <- rep(1/n_stocks, n_stocks)

# Compute the evaluation metrics for the portfolio on the train and test set

balancedPortfolioMetrics_train <- portfolioMetrics(balancedWeights, meanRet_train, risk_train)
balancedPortfolioMetrics_test <- portfolioMetrics(balancedWeights, meanRet_test, risk_test)

print(balancedPortfolioMetrics_train)
print(balancedPortfolioMetrics_test)
```

### PORTFOLIO 3: Randomly Generated weights
```{r}
# Randomly generated portfolios weights

n_randomPortfolios <-5
randomPortfolios <- replicate(n_randomPortfolios, {
  randomWeights <- runif(n_stocks)

  # Normalize to ensure weights sum to 1
  randomWeights <- randomWeights / sum(randomWeights)  
  
  # Evaluation of portfolio on test data

  randomPortfolio_train <- portfolioMetrics(randomWeights, meanRet_train, risk_train)
  randomPortfolio_test <- portfolioMetrics(randomWeights, meanRet_test, risk_test)
  randomPortfolio_train
  randomPortfolio_test
}, simplify = FALSE)

# Print the portfolio metrics
for (i in seq_along(randomPortfolios)) {
  # remove # to view
  #print(randomPortfolios[[i]])
}

```
## COMPARISON BETWEEN PORTFOLIO 1, 2 AND 3 for both test and train sets
```{r}

#Compare the portfolio metrics of the three discussed portfolios for just test set using a table

# Define an empty dataframe to store the results
portfolio_results_train <- data.frame(Portfolio = character(),
                                Return = numeric(),
                                Risk = numeric(),
                                Sharpe_Ratio = numeric(),
                                stringsAsFactors = FALSE)

# Calculate portfolio_1 metrics for  train sets
portfolio_1_Metrics_train <- portfolioMetrics(optimalWeights, meanRet_train, risk_train)
portfolio_results_train <- rbind(portfolio_results_train, c("Portfolio_1", as.numeric(portfolio_1_Metrics_train$Return), as.numeric(portfolio_1_Metrics_train$Risk), as.numeric(portfolio_1_Metrics_train$Sharpe_Ratio)))

# Calculate balanced portfolio metrics
balancedPortfolioMetrics_train <- portfolioMetrics(balancedWeights, meanRet_train, risk_train)
portfolio_results_train <- rbind(portfolio_results_train, c("Portfolio_2", as.numeric(balancedPortfolioMetrics_train$Return), as.numeric(balancedPortfolioMetrics_train$Risk), as.numeric(balancedPortfolioMetrics_train$Sharpe_Ratio)))

# Calculate random portfolio metrics
for (i in seq_along(randomPortfolios)) {
  random_portfolio_name <- paste("Random_Portfolio", i)  
  random_portfolio_metrics_train <- unlist(randomPortfolios[[i]])
  portfolio_results_train <- rbind(portfolio_results_train, c(random_portfolio_name, as.numeric(random_portfolio_metrics_train["Return"]), as.numeric(random_portfolio_metrics_train["Risk"]), as.numeric(random_portfolio_metrics_train["Sharpe_Ratio"])))
}

# Rename the columns
colnames(portfolio_results_train) <- c("Portfolio", "Return", "Risk", "Sharpe_Ratio")

# Print the dataframe containing all portfolio metrics
print(portfolio_results_train)
```

```{r}

#Compare the portfolio metrics of the three discussed portfolios for just train set using a table
# Define an empty dataframe to store the results
portfolio_results_test <- data.frame(Portfolio = character(),
                                Return = numeric(),
                                Risk = numeric(),
                                Sharpe_Ratio = numeric(),
                                stringsAsFactors = FALSE)

# Calculate portfolio_1 metrics 
portfolio_1_Metrics_test <- portfolioMetrics(optimalWeights, meanRet_test, risk_test)
portfolio_results_test <- rbind(portfolio_results_test, c("Portfolio_1", as.numeric(portfolio_1_Metrics_test$Return), as.numeric(portfolio_1_Metrics_test$Risk), as.numeric(portfolio_1_Metrics_test$Sharpe_Ratio)))

# Calculate balanced portfolio metrics 
balancedPortfolioMetrics_test <- portfolioMetrics(balancedWeights, meanRet_test, risk_test)
portfolio_results_test <- rbind(portfolio_results_test, c("Portfolio_2", as.numeric(balancedPortfolioMetrics_test$Return), as.numeric(balancedPortfolioMetrics_test$Risk), as.numeric(balancedPortfolioMetrics_test$Sharpe_Ratio)))

# Calculate random portfolio metrics
for (i in seq_along(randomPortfolios)) {
  random_portfolio_name <- paste("Random_Portfolio", i)  
  random_portfolio_metrics_test <- unlist(randomPortfolios[[i]])
  portfolio_results_test <- rbind(portfolio_results_test, c(random_portfolio_name, as.numeric(random_portfolio_metrics_test["Return"]), as.numeric(random_portfolio_metrics_test["Risk"]), as.numeric(random_portfolio_metrics_test["Sharpe_Ratio"])))
}

# Rename the columns
colnames(portfolio_results_test) <- c("Portfolio", "Return", "Risk", "Sharpe_Ratio")

# Print the dataframe containing all portfolio metrics
print(portfolio_results_test)
```
The comparison between Portfolio_1, Portfolio_2, and the randomly generated portfolios provides valuable insights into their respective performances. Portfolio_1, generated by the genetic algorithm (GA) on manually selected assets, showcases a higher return compared to both Portfolio_2 (balanced weight portfolio) and the random portfolios. This suggests that the GA optimization process successfully identified weights that led to a portfolio with enhanced return potential. However, it's essential to note that higher returns often come with increased risk, which is evident in Portfolio_1's relatively higher risk level compared to Portfolio_2.

In terms of risk, Portfolio_1 exhibits a higher level of risk compared to Portfolio_2. This indicates that while the evolved portfolio may offer potentially higher returns, it also carries a greater degree of volatility and uncertainty. On the other hand, Portfolio_2, which maintains an evenly distributed weight across assets, demonstrates lower risk, albeit at the expense of slightly lower returns. The trade-off between risk and return underscores the importance of aligning portfolio composition with an investor's risk tolerance and investment objectives.

Furthermore, when compared to the randomly generated portfolios, Portfolio_1 generally outperforms in terms of return across different runs. This highlights the efficacy of the GA optimization process in identifying portfolios with superior return potential. However, the variability in risk-adjusted returns, as reflected in the Sharpe ratio, suggests that the performance of Portfolio_1 may fluctuate depending on the specific asset allocation and market conditions.

Overall, while Portfolio_1 demonstrates promising performance in terms of return, investors should carefully consider its associated risk level and evaluate whether it aligns with their risk appetite and investment goals. Additionally, further analysis, such as stress testing or scenario analysis, could provide additional insights into the robustness of the evolved portfolio under different market conditions.

## CREATION OF PORTFOLIOS WITH DIFFERENTLY BALANCED RISK AND RETURN
### a) Prioritize maximizing return without considering risk

```{r Prioritize_return, include=FALSE}
# Modify fitness function to maximize return
fitness_return <- function(weights, meanReturn, covMatrix, risk_weight = 0) {
  # Calculate portfolio return
  portfolio_return <- sum(weights * meanReturn)
  
  # Calculate portfolio risk (standard deviation)
  portfolio_risk <- sqrt(t(weights) %*% covMatrix %*% weights)
  
  # Combine return and risk based on specified weight
  portfolioScore <- risk_weight * portfolio_return - (1 - risk_weight) * portfolio_risk
  
  # Return the negative portfolio score because GA maximizes by default
  return(-portfolioScore)
}

# Set up GA parameters for exploration
GA_return <- ga(type = "real-valued", 
                 fitness = fitness_return, 
                 lower = rep(0, length(myStocks)), 
                 upper = rep(1, length(myStocks)), 
                 meanReturn = colMeans(trainData),
                 covMatrix = cov(trainData),
                 popSize = 50,
                 maxiter =100)
``` 

View optimized weights
```{r}
# Get optimal weights for exploration
optimalWeights_return <- GA_return@solution
print(optimalWeights_return)
```

#### b) Prioritize minimizing risk without considering returns
```{r prioritize_risk, include=FALSE}
# Modify fitness function to minimize risk
fitness_risk <- function(weights, meanReturn, covMatrix, risk_weight = 1) {
  # Calculate portfolio return
  portfolio_return <- sum(weights * meanReturn)
  
  # Calculate portfolio risk (standard deviation)
  portfolio_risk <- sqrt(t(weights) %*% covMatrix %*% weights)
  
  # Combine return and risk based on specified weight
  portfolioScore <- risk_weight * portfolio_return - (1 - risk_weight) * portfolio_risk
  
  # Return the negative portfolio score because GA maximizes by default
  return(-portfolioScore)
}

# Set up GA parameters for exploration
GA_risk <- ga(type = "real-valued", 
                 fitness = fitness_risk, 
                 lower = rep(0, length(myStocks)), 
                 upper = rep(1, length(myStocks)), 
                 meanReturn = colMeans(trainData),
                 covMatrix = cov(trainData),
                 popSize = 50,
                 maxiter =100)
                
```

 View the optimized weight
```{r}
# Get optimal weights for exploration
optimalWeights_risk <- GA_risk@solution
print(optimalWeights_risk)
```

#### c) Equally weighted risk and return
```{r Equally_balanced, include=FALSE}
# Modify fitness function to minimize risk
fitness_risk_return <- function(weights, meanReturn, covMatrix, risk_weight = 0.5) {
  # Calculate portfolio return
  portfolio_return <- sum(weights * meanReturn)
  
  # Calculate portfolio risk (standard deviation)
  portfolio_risk <- sqrt(t(weights) %*% covMatrix %*% weights)
  
  # Combine return and risk based on specified weight
  portfolioScore <- risk_weight * portfolio_return - (1 - risk_weight) * portfolio_risk
  
  # Return the negative portfolio score because GA maximizes by default
  return(-portfolioScore)
}

# Set up GA parameters for exploration
GA_risk_return <- ga(type = "real-valued", 
                 fitness = fitness_risk_return, 
                 lower = rep(0, length(myStocks)), 
                 upper = rep(1, length(myStocks)), 
                 meanReturn = colMeans(trainData),
                 covMatrix = cov(trainData),
                 popSize = 50,
                 maxiter =100)
                
```

View optimized weight
```{r}
# Get optimal weights for exploration
optimalWeights_risk_return <- GA_risk_return@solution
print(optimalWeights_risk_return)
```
#### Evaluate these optimized portfolios for both the train and test sets

```{r}
optimalWeights_return <- as.vector(optimalWeights_return)
optimalWeights_risk <- as.vector(optimalWeights_risk)
optimalWeights_risk_return <- as.vector(optimalWeights_risk_return)

# Call the portfolioMetrics function to calculate the portfolio metrics for these different weighted risk and return portfolios on both test and train sets

#for the return prioritized portfolio
portfolioMetrics_return_train <- portfolioMetrics(optimalWeights_return, meanRet_test,risk_train)
portfolioMetrics_return_test <- portfolioMetrics(optimalWeights_return, meanRet_test,risk_test)

#for the risk prioritized portfolio 
portfolioMetrics_risk_train <- portfolioMetrics(optimalWeights_risk, meanRet_train, risk_train)
portfolioMetrics_risk_test <- portfolioMetrics(optimalWeights_risk, meanRet_test, risk_test)

# for the equally weighted risk, return portfolio 
portfolioMetrics_risk_return_train <- portfolioMetrics(optimalWeights_risk_return, meanRet_train, risk_train)
portfolioMetrics_risk_return_test <- portfolioMetrics(optimalWeights_risk_return, meanRet_test, risk_test)

print("Metrics for optimized portfolio that maximizes return for train dataset")
print(portfolioMetrics_return_train)
print("Metrics for optimized portfolio that maximizes return for test dataset")
print(portfolioMetrics_return_test)

print("Metrics for optimized portfolio that minimizes risk for train dataset")
print(portfolioMetrics_risk_train)
print("Metrics for optimized portfolio that minimizes risk for test dataset ")
print(portfolioMetrics_risk_test)

print("Metrics for optimized portfolio that weighs return and risk equally for train set")
print(portfolioMetrics_risk_return_train)
print("Metrics for optimized portfolio that weighs return and risk equally for test set")
#print(portfolioMetrics_risk_return_test)

```
Firstly, an optimized portfolio was created to maximize return while not giving consideration to risk. This portfolio achieved a relatively high return of 0.0219 for both the train and test datasets. However, it also exhibited higher risk levels compared to other portfolios, with a risk value of 0.8538 for the train dataset and 0.7647 for the test dataset. The Sharpe ratio, indicating risk-adjusted return, was moderate at 0.0257 for the train dataset and 0.0287 for the test dataset.

Conversely, another optimized portfolio was designed to minimize risk with no concern for the return. This portfolio demonstrated lower risk levels of 0.2297 for the train dataset and 0.2149 for the test dataset, albeit with lower returns of 0.0090 and 0.0045, respectively. The Sharpe ratio for these portfolios was 0.0394 for the train dataset and 0.0211 for the test dataset, reflecting the trade-off between risk reduction and potential return sacrifice.

Additionally, an equally weighted portfolio, balancing return and risk, was evaluated. This portfolio achieved a moderate return of 0.1021 for the train dataset and 0.0219 for the test dataset, with corresponding risk levels of 0.8819 and 0.7721. The Sharpe ratio for these portfolios was 0.1158 for the train dataset and 0.0283 for the test dataset, indicating a balanced risk-return profile.

Comparing these portfolios to each other and to the previously examined balanced and random portfolios provides valuable insights into the impact of different risk-return preferences on portfolio performance. Investors can use these findings to tailor their investment strategies based on their risk tolerance and return objectives, aiming to achieve optimal risk-adjusted returns that align with their financial goals.
# Part 2
```{r include=FALSE}
#  Define the asset symbols
assetSymbols <- c("ADD", "SAND", "MCHP", "EPSN", "NINE", "NOVA", "ROAD", "MP", "EXP", "MUR",
                  "COF", "FOA", "CHCI", "POWL", "SIF", "CAT", "UNP", "UPS", "WMT", "PG", 
                  "KO", "ECL", "FCX", "JPM", "V", "AEP", "BAC", "NVDA", "AAPL", "ORCL", 
                  "GOOGL", "COST", "NSRGY", "PM", "AMZN", "TSLA", "NKE", "TM", "MCD", 
                  "HESAY", "NFLX", "TMUS", "DIS", "VZ", "CVX", "EQNR", "XOM", "ABT", 
                  "LRLCY", "NVO", "JNJ", "MRK", "MSFT")
# Create an empty list to save fetched stock data
assetDataList <- list()

# Iterate over each stock symbol in assetSymbols
for (asset in assetSymbols) {
  # Fetch the asset's data
  assetData <- getSymbols(asset, src = "yahoo", from = "2021-01-01", to = "2023-12-31", auto.assign = FALSE)
  
  # Check if data is fetched successfully
  if (!is.null(assetData)) {
    # Save the fetched stock data in the assetDataList
    assetDataList[[asset]] <- assetData
  } else {
    cat("Failed to fetch data for asset:", asset, "\n")
  }
}
#any(is.na(assetDataList))
print(assetDataList)
```

#### Save Data in a .RData file and calculate the monthly return of each asset
```{r view data1}

# Save the data in a .RData from where the data will be loaded from in subsequent runs
save(assetDataList, file = "asset_data.RData")


load("asset_data.RData")
#print(assetDataList)

```

### Monthly retun 
```{r}
# Create empty list to save monthly returns of each asset
monthly_return <- list()

for (asset in assetSymbols) {
  assetData <- assetDataList[[asset]]
  monthly_returns <- monthlyReturn(assetData)
  if (!is.null(monthly_returns)) {
    monthly_return[[asset]] <- monthly_returns
  } else {
    cat("No data available for asset:", asset, "\n")
  }
}

# Create initial dataframe of monthly return by Merging the returns of the first two stocks in the myStocks list

myMonthly_return <- merge(monthly_return[[1]], monthly_return[[2]])

# Merge the remaining stocks to this initial return dataframe
for  (i in 3:length(assetSymbols)) {
  myMonthly_return <- merge(myMonthly_return, monthly_return[[i]])
}

# use the actual asset name as heading as opposed to index
colnames(myMonthly_return) <- assetSymbols

#any_na <- any(is.na(myMonthly_return$ADD))
#print(any_na)
#print(myMonthly_return)
```

#### Split the Data set into train and test sets
```{r}

# Split dataset into train and test sets (80% train, 20% test)
set.seed(123) 
train_indices <- sample(1:nrow(myMonthly_return), 0.8 * nrow(myMonthly_return))
train_data <- myMonthly_return[train_indices, ]
test_data <- myMonthly_return[-train_indices, ]
#print(train_data)
```


#### Asset Selection
```{r}

# Define the corresponding sectors for each asset in assetSymbols
sectors <- c("Entertainment", "Gold", "Semiconductors", "Oil & Gas E&P", "Oil & Gas Equipment & Services",
             "Solar", "Engineering & Construction", "Engineering & Construction", "Building Materials", "Oil & Gas E&P",
             "Credit Services", "Financial Services", "Real Estate - Diversified", "Electrical Equipment & Parts",
             "Aerospace & Defense", "Construction Machinery & Heavy Trucks", "Railroads", "Integrated Freight & Logistics",
             "Discount Stores", "Consumer Packaged Goods", "Soft Drinks", "Specialty Chemicals", "Copper", "Diversified Banks",
             "Consumer Finance", "Utilities - Regulated Electric", "Diversified Banks", "Semiconductors", "Consumer Electronics",
             "Enterprise Software", "Internet Services & Infrastructure", "Hypermarkets & Super Centers", "Packaged Foods",
             "Tobacco", "Internet & Direct Marketing Retail", "Automobile Manufacturers", "Footwear", "Auto Manufacturers",
             "Restaurants", "Luxury Goods", "Entertainment", "Telecommunication Services", "Entertainment",
             "Telecommunication Services", "Oil & Gas Integrated", "Oil & Gas Integrated", "Oil & Gas Integrated",
             "Health Care Equipment", "Personal Products", "Drug Manufacturers - Major", "Drug Manufacturers - Major",
             "Drug Manufacturers - Major", "Software - Infrastructure")

# Create a data frame to store assets and their sectors
asset_sector_df <- data.frame(Asset = assetSymbols, Sector = sectors)

asset_sectors <- setNames(asset_sector_df$Sector, asset_sector_df$Asset)
#Print the data frame
#print(asset_sectors)
#print(asset_sector_df)
```

#### Define functions for the selection of Assets by GA
```{r include=FALSE}

# Define the genetic algorithm functions for asset selection

# Function to initialize the population
initialize_population <- function(population_size, num_assets) {
  population <- matrix(data = sample(c(0, 1), population_size * num_assets, replace = TRUE), ncol = num_assets)
  return(population)
}

# Function to evaluate fitness based on historical performance and sector diversity
evaluate_fitness <- function(population, train_data_with_sectors) {
  fitness_scores <- numeric(nrow(population))
  for (i in 1:nrow(population)) {
    selected_assets <- assetSymbols[population[i, ] == 1]
    selected_data <- train_data_with_sectors[, c("Date", selected_assets)]
    selected_data <- na.omit(selected_data)
    sector_diversity_score <- length(unique(selected_data$Sector)) / nrow(selected_data)
    historical_performance_score <- mean(colMeans(selected_data[, -1]))
    fitness_scores[i] <- sector_diversity_score + historical_performance_score
  }
  return(fitness_scores)
}

# Function for crossover
crossover <- function(parent1, parent2) {
  crossover_point <- sample(2:(length(parent1) - 1), 1)
  child1 <- c(parent1[1:crossover_point], parent2[(crossover_point + 1):length(parent2)])
  child2 <- c(parent2[1:crossover_point], parent1[(crossover_point + 1):length(parent1)])
  return(list(child1, child2))
}

# Function for mutation
mutate <- function(chromosome, mutation_rate) {
  mutated_chromosome <- chromosome
  for (i in 1:length(mutated_chromosome)) {
    if (runif(1) < mutation_rate) {
      mutated_chromosome[i] <- 1 - mutated_chromosome[i]
    }
  }
  return(mutated_chromosome)
}

# Main genetic algorithm function
genetic_algorithm <- function(population_size, num_generations, mutation_rate, train_data_with_sectors) {
  num_assets <- ncol(train_data_with_sectors) - 1
  population <- initialize_population(population_size, num_assets)
  for (gen in 1:num_generations) {
    fitness_scores <- evaluate_fitness(population, train_data_with_sectors)
    # Selection
    selected_indices <- sample(1:population_size, size = population_size, replace = TRUE, prob = fitness_scores)
    mating_pool <- population[selected_indices, ]
    # Crossover
    offspring <- matrix(0, nrow = population_size, ncol = num_assets)
    for (i in 1:(population_size/2)) {
      parents <- mating_pool[sample(1:population_size, size = 2, replace = TRUE), ]
      children <- crossover(parents[1, ], parents[2, ])
      offspring[(2 * i - 1), ] <- children[[1]]
      offspring[(2 * i), ] <- children[[2]]
    }
    # Mutation
    for (i in 1:population_size) {
      offspring[i, ] <- mutate(offspring[i, ], mutation_rate)
    }
    population <- offspring
  }
  return(population)
}

# Example usage
population_size <- 100
num_generations <- 50
mutation_rate <- 0.01

# Perform genetic algorithm for asset selection
selected_assets_population <- genetic_algorithm(population_size, num_generations, mutation_rate, train_data_with_sectors)

# Select the best chromosome (set of assets)
best_chromosome <- selected_assets_population[1, ]
selected_assets <- assetSymbols[best_chromosome == 1]

# Print the selected assets
print(selected_assets)
```

### Pass these selected assets to the GA function from part 1
```{r include=FALSE}
# Set up GA parameters for portfolio optimization with selected assets

# Set up GA parameters for portfolio optimization with selected assets
GA <- ga(type = "real-valued",
         fitness = fitnessFunction,
         lower = rep(0, length(selected_assets)),
         upper = rep(1, length(selected_assets)),
         meanReturn = colMeans(new_train_data),
         covMatrix = cov(new_train_data),
         popSize = 50,
         maxiter = 100)
```

```{r}
# Get optimal weights for the selected assets
optimal_weights <- GA@solution
print(optimal_weights)
```

### Use optimized weights on the test data and eEvaluating the portfolio
```{r}
# Assign the mean return and risk to a variable

mean_return_test <- colMeans(new_test_data)
risk_test <- cov(new_test_data)

mean_return_train <- colMeans(new_train_data)
risk_train <- cov(new_train_data)

# Change the optimal_weight from a matrix to a vector
optimal_weights <- as.vector(optimal_weights)

# Calculate portfolio metrics for train and test sets

portfolio_metrics_train <- portfolioMetrics(optimal_weights, colMeans(new_train_data),cov(new_train_data))

portfolio_metrics_test <- portfolioMetrics(optimal_weights, colMeans(new_test_data),cov(new_test_data))

print(portfolio_metrics_train)
print(portfolio_metrics_test)

```
Observing the performance of the portfolio selection using genetic algorithms (GAs) reveals significant insights. Firstly, the GA-based approach in part 2 exhibited a broader diversification compared to the manually selected assets from part 1, as it identified assets from various sectors. This diversity is crucial for mitigating sector-specific risks and enhancing portfolio resilience to market fluctuations.

Furthermore, despite differences in asset selection methods, the performance metrics of portfolios optimized using GAs in part 2 remained consistent with those of the manually selected assets. Both sets of portfolios achieved similar levels of return, risk, and Sharpe ratio, indicating that the GA-based approach effectively captured the characteristics of a well-diversified portfolio.

The optimized portfolios from part 2 also exhibited a balanced risk-return tradeoff, akin to the manually selected assets. This suggests that the GA-based approach successfully identified assets that collectively provided attractive returns while managing portfolio risk effectively.

Moreover, integrating feedback from the GA optimizing portfolio weights into the asset selection process in part 3 aimed to further enhance portfolio performance. This approach leveraged insights gained during portfolio optimization to inform asset selection decisions, potentially leading to portfolios with improved risk-adjusted returns.

In summary, the GA-based asset selection methods demonstrated effectiveness in constructing portfolios with desirable risk-return profiles, comparable to manually selected assets. Integrating portfolio optimization feedback into the asset selection process holds promise for further enhancing portfolio performance and warrants further investigation.

Integrating the two approaches involved using feedback from the GA that optimized the portfolio to inform the asset selection process by the other GA. This combined approach aimed to enhance portfolio performance by leveraging both asset selection criteria and optimization of portfolio weights. The performance of this integrated approach was compared to the individual approaches discussed earlier, providing insights into the effectiveness of combining asset selection and portfolio optimization using GAs.

Overall, these analyses demonstrate the importance of careful asset selection and portfolio optimization techniques in achieving desirable risk-adjusted returns, highlighting the potential of genetic algorithms in enhancing investment strategies.





